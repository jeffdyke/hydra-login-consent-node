# Claude Oauth Flow

## Configuration

### Custom MCP Connector

- MCP Server endpoint: <https://auth.staging.bondlink.org>
- ClientID: From Google
- Redirect URI: <https://claude.ai/api/mcp/auth_callback>

Secrets are not saved in Claude, though it has the option, with this flow it makes no sense.

### Hydra client configuration

Further description to follow. Current client configuration, this client is a gateway to more DCR clients

Notes:

- Both redirect url's are registered as both will be target. This is equally important with Google's client and Hydras, since we'll handle `PKCE` validation
- Scopes of `offline && offline_access` are never sent to Google, You inform Google by `access_type` and drop the scope from request
- `skip_consent` and `skip_login` are both set to false.  Here hydra normal Oauth flow is utilized to stick directly to the Authorization flow.
- `PKCE` Validation, while shown in the configuration with `RS256` is not being used, the application is validating PKCE tokens.
  - Hydra does not generate a `codeVerifier` for the incoming `code_challenge` and `state`.
    - That would be part of the `kratos` flow, and out of scope for Hydra
  - There may be a better client configuration, yet to be seen, there are no bugs in this config that imped progress.



```json
{
  "client_id": "a8c11f42-a9d7-4437-9b0b-cd48e25a71a5",
  "client_name": "",
  "client_secret_expires_at": 0,
  "client_uri": "",
  "created_at": "2025-10-17T20:09:02Z",
  "grant_types": [
    "authorization_code",
    "refresh_token"
  ],
  "jwks": {},
  "logo_uri": "",
  "metadata": {},
  "owner": "",
  "policy_uri": "",
  "redirect_uris": [
    "https://auth.staging.bondlink.org/callback",
    "https://claude.ai/api/mcp/auth_callback"
  ],
  "request_object_signing_alg": "RS256",
  "response_types": [
    "code",
    "id_token"
  ],
  "scope": "email profile openid offline offline_access",
  "skip_consent": false,
  "skip_logout_consent": false,
  "subject_type": "public",
  "token_endpoint_auth_method": "none",
  "tos_uri": "",
  "updated_at": "2025-10-28T14:21:42.383122Z",
  "userinfo_signed_response_alg": "none"
}
```

## Discovery Endpoints

Claude was configured with https://auth.staging.bondlink.org

It then will probe this endpoint for the following, which are redirects in nginx

- /.well-known/(oauth-authorization-server|oauth-protected-resource) > [All In One Config](https://auth.staging.bondlink.org/.well-known/openid-configuration)

This tells Claude the next urls of interest are:

- [Authorization](https://auth.staging.bondlink.org/oauth2/auth)
  - This url is handled by utilizing [HTTP Proxy Middleware](https://www.npmjs.com/package/http-proxy-middleware). Registered with `app.user("/ouath2/token", proxyMiddleware)`
    - The registration must come after registering `express-session` and before any registration of a `body-parser`, the former is a helper, the latter can modify the body
    - [ProxyMiddleware](https://github.com/jeffdyke/hydra-login-consent-node/blob/master/src/setup/proxy.ts)
      - This sets session data b/c the application would be otherwise skipped b/c of configuration within `/.well-known/openid-configuration`.
         All signs led to middleware, rather than modifying the autogenerated Oauth2 routes
- [Authentication](https://auth.staging.bondlink.org/oauth2/token)
  - Hydra is no longer part of the flow here, see PKCE comments, middleware is not used, the application defines the entire route, two paths
  - [Called claude.ts currently](https://github.com/jeffdyke/hydra-login-consent-node/blob/master/src/routes/claude.ts)
    - Unless changed this file will handle both `grant_type == authorization && grant_type == token_refresh`
      - Last bugs are in refresh token

Supporting code exists for both, especially `/oauth2/token` more forthcoming.

## Current State - of the doc, not the code

- claude, with its configuration, makes a request
  - The endpoint is `/oauth2/auth`
    - Proxy code:
      - Creates a new session, as this is the entrypoint
      - JSON encodes all fields and writes it to generated session hash for this request
        - Each auth request only lasts seconds
      - Removes `code_challenge`, `code_challenge_method` and `state` for the forwarded request
        - This data is saved to redis before the redirect, and the new `state` is `req.session.id`
          - All part of doing the `PKCE` validation in the app
- The request is proxied to `http://hydra_public/oauth2/authorize` over the local network to avoid the nginx redirects
  - Here `Hydra`
    - Redirects to `/login?login_challenge=unique-hash`
      - Currently redirect to a controller that handles the request and sends the prescribed `POST`
      - `POST /login`
        - Respond positively to the challenge
        - Generate a new `googleAuthURL` which will be a redirect, will full params for the request
      - `GET /consent`
        - After a positive login challenge, the `consent` flow opens
        - All browser redirects are managed by the Google OAuth Consent Flow
        - Application is handling both `GET /consent?consent_challenge` and `POST /consent`
          - Exactly the same as `login`, the challenge is created and accepted in one controller
  - Middleware callback is `https://auth.staging.bondlink.org/callback` is the configured callback endpoint
    - This is a gateway between the request that `claude` has made, the data saved in `hydra` and `google` as the provider
    - `code` is the only query param
      - A unique, one time hash, generated by client/claude
    - Use `code` and the Google client credentials to query googleOAuthTokens, for a one time token
      - Store `code` in redis
      - Create a new unique token, uses `crypto.randomBytes(32).toString('base64url')`
      - This code and the original `state`, which is Claude's and not the one we've mapped to `req.session.id` are...
        - Sent to Claude's redirectURL, which is validated by Google before returning the code
          - The new `authCode` is known **only** to the application, as is the original Claude `state`
    - Response:
      - The client(Claude) will take the new `authCode` and create a `PKCE` hash from the same secret that sent the first to `/oauth2/auth`
      - The clients `verifier` secret and never sent, so we create a new verifier that uses the `code_challenge` and `code_challenge_method`
        - The locally encoded hash with the private verifier must match the encoded hash that was sent from Claude
          - The public data is the method and challenge, our independent hashes are the proof
    - Now that we have `app.hash(code_challenge) == claude.hash(code_challenge)` and the previous state that was sent from the client (Claude)
      - This is exchanged for a `GoogleToken`, for `authorization_code`, very short lived
      - Redirect is sent with both `access` and `refresh_tokens` back to Claude
    - Once they have this, they can start the `refresh_token` flow
